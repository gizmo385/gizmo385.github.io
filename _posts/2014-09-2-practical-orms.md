---
layout: post
title: ORMs in Practical Applications
---

I would first of all like to apologize for the lack of posts over the past few months. During the summer, I have been partaking in my first internship at a software development company in Tucson, [Elegant Thought](http://elegantthought.com/).

During this internship, I worked on a proprietary Android app and as a part of the development process worked on an [Object-Relational Mapper](http://en.wikipedia.org/wiki/Object-relational_mapping).

### Object-Relational Mapping

The purpose of an object-relational mapper (ORM) is to provide a layer of abstraction that will allow for java objects to be mapped to objects that can be placed in a database. This abstraction layer comes with many pros and cons that must be taken into account when deciding whether or not an ORM is a viable solution to a problem.

### The Advantages of an ORM:

#### Simplicity:
Incorporating an ORM into your application abstracts away all of the nitty-gritty database design and allows your code to flow seemlessly across your application. By abstracting away the database-design aspect of your application, you can create a uniform experience across your codebase, which means that those working on your application don't necessarily have to understand [SQL](http://en.wikipedia.org/wiki/SQL) or [Cypher](http://en.wikipedia.org/wiki/Cypher_Query_Language) or whatever proprietary database query language may be used in your application.

In addition to abstracting the database the design aspects of your application, including an ORM in your application also allows for your database to be as modular as your application requires it to be. As long as you operate within the bounds of your ORM, you can easily change the backing data schema for your database without having to make heavy overhauls to your application. If you instead opted to use an in-line query language, changing your data schema might require recreating a wide array of individual database queries to recreate previous behavior.

#### Cleaner Code:
SQL is ugly. Plain and simple. While it is generally a rather simple query language, it is also quite ugly when it is plastered in the middle of a Python script. ORMs solve this problem. Because an ORM abstracts away all of the messy database interactions and performs it all behind the scenes, inline database queries quickly become a thing of the past. They especially make complex queries vastly easier by automatically performing the necessary table joins behind the scenes rather than having it baked into the query.

#### Automatic Query Optimization:
One of the most complicated elements of designing the ORM this summer was ensuring that the SQL that was generated by our library was as efficient as we could reasonably make it. For example, if you are a performing a query that spans several different relationships, some of which join extremely large tables, then immediately joining all of those tables is going to create extremely large performance problems within your application. To solve this problem, we wrote our query generation so that the tables would be filtered as the query grew. This prevented large tables, potentially containing hundreds or thousands of columns, from being joined on other large tables which might also contain hundreds or thousands of columns. This allows for complex relationship chains to be traversed without crippling the runtime performance of your application.

While an ORM might never be able to completely optimize a particular query, being able to automatically optimize the vast majority of queries is a huge boon when designing an application.

### The Disadvantages of an ORM:

#### Design Inflation:
Dependency management is a necessary evil. Automatic build systems have made this necessary evil a lot easier to stomach and manage, but the necessary evil still exists. When you're designing a large application, running into build system problems is just a part of the job. Whether it's about getting different dependencies to play nicely together or getting your development platform to cooperate, you're bound to run into problems somewhere down the line. Replacing your databases with an ORM is just adding another dependency onto what may already be a large stack of dependencies, all depending on their own individual array of projects and applications to properly function.

The addition of another dependency also bloats application size. When you ship your application, now you must also ship this large and bloated ORM to go along with it. For some, this simply isn't worth the other possible disadvantages that come along with including an ORM in your application.

#### Inability to Optimize:
For homebrewed databases, sometimes there are optimizations that can be made that aren't necessarily apparent to those who do not have experience with the application. These sorts of optimizations, grown from personal experience, familiarity with a project, and the blood, sweat, and tears of those desigining the application are optimizations that simply can't be made by an ORM. An ORM lacks the necessary knowledge of its problem space to make an informated decision about whether or not a query can be further optimized. This is a purely human ability that isn't something that is easily replacable and can be seen as a large detriment to someone working on the project

### Conclusion:
ORMs can be a fantastic piece of software that can save a developer a large amount of time over inline query languages, however the benefits are not infinite and the disadvantages are numerous. There are many who believe that Object/Relational problem does not have a convinient solution and that there is no best solution that might work best for all developers. Some even go as far to say that ORMs are the [Vietnam of Computer Science](http://blogs.tedneward.com/2006/06/26/The+Vietnam+Of+Computer+Science.aspx), wasting the time of developers everywhere with their own unique quirks and quagmires that developers may spend countless hours wading through attempting to figure out where the bottlenecks in their code are.

When deciding whether or not an ORM is best for your application, it is important to consider the advantages and disadvantages that come along with it. It is also paramount that a developer realizes that an ORM is not going to solve all of the problems that crop up when designing a database schema that accurately reflects their problem space.
