---
layout: post
title: Algebraic Data Types & Clojure
---

### What are Algebraic Data Types?

[Algebraic data types](http://wikipedia.org/en/Algebraic_data_type) (ADTs) are a feature present
in many functional programming languages, such as
[Haskell](http://wikipedia.org/en/Haskell_(programming_language)) and
[Scala](http://wikipedia.org/en/Scala_(programming_language)). ADTs allow you to define a type by
defining the different forms that type can take. For example, you could express a binary tree by
saying that it falls under one of 3 categories:

  1. An empty node.

  2. A leaf node, containing only a value.

  3. A tree node, containing 2 children (left and right).

Definitions like these make it easy to create functions which operate on the ADT by specifying the
behavior that should be followed based on the different values that type can take. Before we define
our syntax, let's first examine how ADTs are used in other languages.

### ADTs in Haskell

Haskell is generally the poster child for functional programming languages and as such I'm going to
leverage it for these examples. It should be noted however that my Haskell skills are somewhat
limited so I will be basing this example off of code found on Wikipedia. Let's look at one way we
might define the above tree example using ADTs in Haskell:

```haskell
data Tree a = Empty
            | Leaf a
            | Node Tree Tree
```

The above example is precisely why ADTs are incredibly handy - they read like plain English. It
becomes incredibly simple to understand the full range of possibilities for a type. It also makes it
incredibly intuitive to define operations based upon the different values your type might take. As
an example, I am going to use the definition of a function to calculate the depth of a tree as
described on Wikipedia:

```haskell
depth :: Tree -> Int
depth Empty = 0
depth (Leaf n) = 1
depth (Node l r) = 1 + max (depth l) (depth r)
```

As you can see, functions operating on ADTs become incredibly brief and easily expressible. While
some of this is due to the conciseness of the language and how expressive it is, you'll see that
we'll soon be able to define something very similar in Clojure.

### So how do they look in Clojure?

The syntax that this ADT implementation will use will look like this:

```clojure
(defadt Tree
  (Empty)
  (Leaf value)
  (Node left right))
```

This syntax is incredibly similar to the Haskell code. We will also see that we can define the depth
function described above like so:

```clojure
(defmulti depth adt-type)
(defmethod depth Empty [_] 0)
(defmethod depth Leaf [_] 1)
(defmethod depth Node [node]
  (+ 1 (max (depth (node :left)) (depth (node :right)))))
(defmethod depth :default [_] 0)
```

Once again, like the example above, it becomes extremely easy to read this function and to
understand what it is doing.

### Implementation

Alright, enough talk. Let's get down to the brass tacks and actually implement this. The actual
types will be represented as maps with the proper metadata attached to them. We will then define
functions that allow for us to easily interact with our types. First, let's define our
`defadt` macro:

```clojure
(defmacro defadt [adt-name & constructors]
  `(do
     ; Define our test function
     (defn ~(symbol (str adt-name "?")) [~'obj]
       (= ~(str adt-name) (adt-name ~'obj)))
     ; Create our type constructors
     ~@(for [[type-name & fields] constructors]
         (apply (partial emit-constructor adt-name type-name)
                 fields))))
```

This macro does two things:

  1. It defines a test function which will check if a given object is a part of the defined ADT. So
     for the tree ADT defined above, a function `Tree?` would be generated by this macro.

  2. Creates the constructor for each case of the ADT. In the case of the tree ADT, 3 functions
     would be defined: `Empty`, `Leaf`, and `Node`.

There are a couple problems with this macro however - most notably is that it isn't complete. It
references 2 functions, `adt-name` and `emit-constructor`, which we have yet to implement. Let's
examine the `emit-constructor` function as that does a fair amount of the heavy lifting:

```clojure
(defn- emit-constructor [adt-name type-name & fields]
  (let [type-name# (symbol type-name)
        metadata {:adt (str adt-name) :adt-type type-name#}]
    (if (empty? fields)
      ; Can't create an empty struct, so create map instead
      `(defn ~type-name# [] (with-meta {} ~metadata))

      ; Define a struct to collect arguments into
      `(defn ~type-name# [~@fields]
         (with-meta
           (struct (create-struct ~@(map keyword fields)) ~@fields)
           ~metadata)))))
```

The first thing that this function does is ensure that the metadata and symbols are created. The
metadata for these types consists of 2 fields:

  1. The name of the adt that this value is constrained in.

  2. The particular sub-type in the ADT that this is. This is assigned as the symbol for the
     type-name which allows us to dispatch based on symbols like Empty and Leaf.

After that, it creates a function which will be used to instantiate new instances of these types.
A distinction is made between types which have arguments and those which do not. Empty types are
defined as empty maps with metadata whereas types with arguments are created as structs. Now that we
have actually created our ADT implementation, let's begin looking at the utility functions used by
this implementation, including `adt-name`.

```clojure
(defn adt-name
  [obj]
  (-> obj meta :adt))

(defn adt-type
  [obj]
  (-> obj meta :adt-type))
```

Both of these functions serve as metadata assessors for ADT sub-types and are helpful both for
extracting information and as dispatch functions for multimethods.

### Conclusion

ADTs provide an interesting way of defining types in a system and allow for incredibly concise
function definitions. They're also just really fun to implement and provide an interesting example
of what is possible with macros using a relatively small amount of code. The code from this post is
available in my [LearningClojure](https://github.com/gizmo385/LearningClojure/) repository
[here](https://github.com/gizmo385/LearningClojure/blob/master/adt/src/adt/core.clj).

As I noted in this post, my Haskell skills are particularly rusty, so if you find any syntax errors
in this post, feel free to submit a pull request or message me and I will be happy to fix them.

### Addendum

While messing with the syntax over the past few days, I discovered that it is possible to get
slightly closer to mimicing the Haskell syntax for defining an ADT. Before explaining the change,
note that this is not meant to be practical! The implementation of this involves 2 steps:

  1. Expect a second mandatory positional argument, an equals sign.

  2. Partition the variable positional arguments by the | symbol and then filter out the lists that
     only contain the vertical bar. This creates the right lists that will be emited as
     constructors. The macro definition is as follows:

```clojure
(defmacro data
  [adt-name equals-sign & constructors]
  `(do
     (defn ~(symbol (str adt-name "?")) [~'obj]
       (= ~(str adt-name) (adt-name ~'obj)))
     ~@(for [[type-name & fields]
             (filter (partial not= '(|))
                     (partition-by (partial = '|) constructors))]
         (apply (partial emit-constructor adt-name type-name)
                 fields))))
```

This allows you to define the tree from above like this:

```clojure
(data Tree = Empty | Leaf value | Node left right)
```
